%
%~~
%~~ Implementação
%~~
%
\section{Implementação} % (fold)
\label{sec:implementação}

A implementação do sistema foi dividida em duas partes principais: aplicação do servidor e aplicativo móvel para iPhone. As duas partes foram implementadas paralelamente por cada integrante do grupo e foram realizados testes para cada funcionalidade desenvolvida. Foram especificadas interfaces de comunicação entre o servidor e o dispositivo móvel afim de padronizar e estabelecer as trocas de informações entre ambos. 

Neste capítulo são descritos separadamente os procedimentos executados para implementação de cada parte do projeto (servidor e aplicativo móvel) com seus respectivos códigos-fonte. Inicialmente é apresentada a implementação referente ao servidor separada por funcionalidades e por último é explicado a implementação em maiores detalhes do aplicativo móvel construído na plataforma \emph{iOS} e os componentes utilizados.

%
%~~
%~~ Servidor
%~~
%

\subsection{Servidor} % (fold)
\label{sub:servidor}

Para que o desenvolvimento fosse ágil, utilizou-se o \emph{Scaffolding} do \emph{Rails}. O \emph{Scaffolding} gera toda a parte de CRUD dos objetos, inclusive o \emph{script} de criação de tabela no banco de dados, utilizando-se o \emph{WebService} \emph{RESTful} para acesso, criação e edição dos dados.

Foi registrado um domínio gratuito no site \url{http://www.co.cc/} com o nome \url{betterwayserver.co.cc} e foi contratado um plano de hospedagem de \emph{site} nos servidores da empresa TeHospedo: serviços de internet \cite{TeHospedo:site}, que fornece hospedagem \emph{Linux} para aplicações \emph{Ruby on Rails}.


\subsubsection{Dificuldades iniciais} % (fold)
\label{ssub:dificuldades_iniciais_servidor}



% subsubsection dificuldades_iniciais (end)

%
%~~
%~~ Criação de eventos
%~~
%

\subsubsection{Criação de eventos} % (fold)
\label{ssub:criação_de_eventos}

Os eventos do trânsito são criados pelo usuário através do aplicativo móvel. O servidor tem o papel de receber as informações do novo evento e armazená-las no banco de dados.

Ao criar um recurso no \emph{Scaffolding} são geradas as classes do \emph{model} do recurso e seu \emph{controller} para acesso via requisições HTTP. Para criação de um novo evento é necessário o envio de um POST para o endereço \url{http://betterwayserver.co.cc/eventos} com as informações do novo evento nos parâmetros da requisição. O método \emph{create} da classe \emph{EventosController} é encarregada de tratar essas requisições.

O horário de criação do evento é obtido do relógio do servidor para evitar que o usuário envie informação errada, pois o horário do dispositivo pode ser configurado manualmente.

O arquivo de imagem do evento é obtido via POST \emph{multipart/form-data} e os dados binário da imagem são armazenados diretamente no banco de dados. Este método de envio é o mesmo utilizado em páginas HTML que utilizam formulários que necessitam de \emph{upload} de arquivo.

% subsubsection criação_de_eventos (end)

%
%~~
%~~ Consulta de eventos
%~~
%

\subsubsection{Consulta de eventos} % (fold)
\label{ssub:consulta_de_eventos}

O servidor deve fornecer as informações dos eventos atuais aos usuários. Para isso o aplicativo móvel pode acessar os dados dos eventos através de um GET no endereço \url{http://betterway.co.cc/eventos} de duas maneiras:

\begin{enumerate}
	\item \textbf{Eventos localizados:}
	
	O servidor envia somente eventos próximos à coordenada informada pelo usuário. O cliente deve informar uma coordenada através dos parâmetros ``latitude'' e ``longitude'' e, opcionalmente, uma área de abrangência através dos parâmetros ``delta\_latitude'' e ``delta\_longitude''.
	
	\item \textbf{Todos eventos:}
	
	O servidor envia todos os eventos armazenados em seu banco de dados. Para acessar todos os eventos, basta o cliente requisitar o endereço através de um GET sem informar as coordenadas geográficas.
	
\end{enumerate}

Esta requisição é tratada pelo método \emph{index} da classe \emph{EventosController}.

% subsubsection consulta_de_eventos (end)

%
%~~
%~~ Consulta de eventos
%~~
%

\subsubsection{Temporização do evento} % (fold)
\label{ssub:temporização_do_evento}

Os eventos informados pelos usuários são exibidos durante 30 minutos. Após esse período eles são marcados como inativos no banco de dados, não sendo mais informados pelo servidor.

Para a implementação da atualização dos registros no banco de dados utilizou-se o ``crontab'' do servidor. O ``crontab'' é um utilitário dos sistemas Unix e Solaris que permite a execução de comandos (tarefas) em \emph{background} a cada intervalo de tempo especificado.

Criou-se então, uma tarefa que atualiza o banco de dados inativando os eventos que ultrapassarem 30 minutos a partir do horário em que foram informados. Essa tarefa é executada a cada cinco minutos no servidor para que não haja sobrecarga no mesmo.

% subsubsection temporização_do_evento (end)

%
%~~
%~~ Criação de registros
%~~
%

\subsubsection{Criação de registros} % (fold)
\label{ssub:criação_de_registros}

Os registros são dados armazenados no servidor para interpretação da situação do tráfego nas ruas em que os usuários do sistema viajam. O dispositivo móvel envia de tempos em tempos as informações de posição, velocidade e identificação do mesmo. Essas informações são armazenadas no banco de dados do servidor, que posteriormente analisa-as e estima o trânsito em determinadas vias.

O envio do registro é feito através de um POST para o endereço \url{betterway.co.cc/registros} e o método \emph{create} da classe \emph{RegistrosController} é o responsável por manipular essas requisições.

O horário de envio é obtido pelo relógio do servidor pelo mesmo motivo citado anteriormente - evitar erro de informação já que o usuário pode ajustar manualmente o horário do dispositivo móvel.

% subsubsection criação_de_registros (end)

%
%~~
%~~ Criação de rotas
%~~
%

\subsubsection{Criação de rotas} % (fold)
\label{ssub:criação_de_rotas}

O servidor é responsável pela criação de rotas para os dispositivos móveis do sistema. Como a criação de rotas está fora do escopo do trabalho proposto, foi utilizada a API do \emph{Google Maps}, via \emph{Webservices}, para geração de rotas entre dois pontos.

O procedimento de criação de rota segue o seguinte fluxo:
\begin{enumerate}
	\item O usuário, ao solicitar uma rota, dispara uma requisição HTTP ao servidor informando as coordenadas de origem e destino da rota desejada.
	\item O servidor recebe essa requisição e dispara uma nova requisição para a API do \emph{Google Maps} solicitando rotas entre as duas coordenadas informadas pelo usuário.
	\item A API do \emph{Google Maps} retorna rotas para o servidor estruturada em formato JSON.
	\item O servidor interpreta as rotas, verificando se há algum trecho em que há problemas de fluidez, de acordo com as informações armazenadas no seu banco de dados.
	\item O servidor retorna ao usuário a rota que não encontrar problemas de fluidez em formato estruturado JSON.
\end{enumerate}

A classe \emph{RotaController}, responsável por este procedimento de criação de rotas no servidor.

A API do \emph{Google Maps} utilizada envia os dados com o desenho da rota (\emph{polyline}) de forma codificada. O algoritmo de codificação é disponibilizado pelo \emph{Google} em \cite{Google:MapsAPI:EncodedPolyline}. Para que a rota seja desenhada corretamente no dispositivo móvel, é necessário fazer a descodificação dessa informação para coordenadas geográficas. Esta descodificação é realizada no servidor antes de enviar as informações para o cliente através do uso da biblioteca \emph{polyline\_decoder} \cite{PolylineDecoder}.

% subsubsection criação_de_rotas (end)

%
%~~
%~~ Trânsito
%~~
%

\subsubsection{Trânsito} % (fold)
\label{ssub:trânsito}



% subsubsection trânsito (end)

% subsection servidor (end)


%
%~~
%~~ Aplicativo móvel
%~~
%

\subsection{Aplicativo móvel} % (fold)
\label{sub:aplicativo_móvel}

A aplicação \emph{BetterWay} construída para o ambiente \emph{iOS} é o componente principal do projeto, tendo como objetivo controlar a requisição de rota para o usuário e da visualização da malha da situação de trânsito no mapa. Nesse contexto, todas as lógicas de visualização do trânsito estão contidos nesse módulo. Contém rotinas para envio constante de dados do usuário sobre sua posição e velocidade e também é responsável pelo envio de eventos e gerenciamento de endereços.

Um modelo de diagrama de classes simplificada da aplicação e o diagrama de navegação estão nas seções~\ref{sec:modelo_de_classes} e \ref{sec:diagrama_navegacao} do apêndice~\ref{cha:especificação_de_requisitos_do_sistema} respectivamente.
 

%
%~~
%~~ Dificuldades iniciais
%~~
%

\subsubsection{Dificuldades iniciais} % (fold)
\label{ssub:dificuldades_iniciais}

As dificuldades de construir a aplicação \emph{BetterWay} para o dispositivo iPhone vem do momento de sua criação, uma vez que o grupo não possui o conhecimento sobre o \emph{framework} de mapas e de requisições web. 
No estudo do \emph{framework} de mapas para o \emph{Cocoa Touch}, chamado \emph{MapKit}, não existia métodos diretos para desenho de rotas e de camadas auxiliares para uma camada de desenho na visualização do mapa. Implementamos métodos indiretos para desenho através do \emph{framework} \emph{CoreGraphics} que deixava a aplicação sobrecarregada, pois neste método era necessário a recalculação de todas marcações realizadas no mapa a cada transição de movimento.
Porém com o lançamento do SDK 4.0 no final do mês de Agosto melhorias foram implementadas no \emph{framework MapKit}, sendo agora possível a implementação de uma camada gráfica encima do mapa. A partir do estudo dessa camada, conseguimos implementar uma solução mais dinâmica onde já não era mais ncessário o recalculo de todas marcações para cada mudança no mapa.

% subsubsection dificuldades_iniciais (end)


%
%~~
%~~ Bibliotecas utilizadas
%~~
%

\subsubsection{Bibliotecas utilizadas} % (fold)
\label{ssub:bibliotecas_utilizadas}

Para a aplicação no dispositivo iPhone, utiliza-se duas bibliotecas auxiliares na implementação.

\textbf{\emph{JSON}:} Biblioteca de codificação/decodificação do protocolo padrão \emph{JSON} para leitura como dados para a linguagem \emph{Objetive-C}. Protocolo \emph{JSON} é utilizado como interface de comunicação entre o dispositivo móvel e o servidor.

\textbf{\emph{ASIHTTPRequest}:} Biblioteca auxiliar para envio de requisições web nas utilizações \emph{GET}, \emph{POST}, \emph{UPDATE} e \emph{DELETE}. Realiza os procedimentos de verificação e delegação dos métodos existentes no \emph{Objetive-C}.

% subsubsection bibliotecas_utilizadas (end)

%
%~~
%~~ Classe delegadora
%~~
%

\subsubsection{Classe delegadora: \emph{MapDirection}} % (fold)
\label{ssub:classe_delegadora_mapdirection}

Classe Delegadora principal da aplicação. Responsável por informar sobre a condições e informações básicas do aparelho e de coordenar todas as View Controllers do aplicativo, além de ser o responsável por manter as listas de permanências de dados sobre os últimos endereços usados e endereços favoritos.

Os dados a serem armazenados são manipulados pela classe NSUsersDefault, que guarda no SandBox da aplicação. Ao iniciar a aplicação, o método loadDatabase é chamado. Ao encerrar a aplicação, a classe delegate captura essa notificação e assim o processo se retenção de dados é realizada.

\textbf{Reachability:} Para o verificamento de conectividade do aparelho, implementou-se uma classe herdada de \emph{SCNetworkReachability}, disponibilizada pela Apple a partir do \emph{SystemConfiguration.framework}. Verifica-se a conexão com a internet via \emph{edge}/\emph{3G} ou \emph{wifi}.



% subsubsection classe_delegadora_mapdirection (end)

%
%~~
%~~ View Controller
%~~
%

\subsubsection{View Controller Principal: \emph{BetterWayViewController}} % (fold)
\label{ssub:view_controller_principal_betterwayviewcontroller}

Esta sessão contém a descrição da classe central da aplicação, sendo o responsável pela tela principal. Possui o mapa onde é identificado as funcionalidades de geração de rotas, informação do trânsito e de eventos para o usuário. Possui o \emph{UINavigatorController}, que conecta todas as telas da aplicação.

\textbf{CLLocationManager:} Classe disponibilizada pela Apple que faz a verificação da disponibilidade do GPS. Possui diversos métodos de utilização do GPS, entre elas o método de buscar a posição atual do usuário.



% subsubsection view_controller_principal_betterwayviewcontroller (end)

%
%~~
%~~ Módulo de geração de rota
%~~
%

\subsubsection{Módulo de geração de rota} % (fold)
\label{ssub:módulo_de_geração_de_rota}

Este módulo foi estruturada diversas View Controllers necessárias para o fluxo de interatividade com o usuário, que entra com os dados da via de destino e origem no aparelho a fim de gerar uma rota evitando os congestionamentos conhecidos pelo servidor.

O fluxo foi definido de tal maneira recursiva para o reaproveitamento das mesmas classes, sendo que ao passar o endereço de destino e o de origem, o usuário passe pelas classe de telas. O diagrama de fluxo encontra-se na seção~\ref{sec:protótipo_de_navegação} do apêndice~\ref{cha:projeto_da_interface_de_usuário}.  Decidimos por implementar algumas funcionalidades auxiliares como um armazenamento de endereços como um histórico e como uma lista favoritos, para uma melhor experiência de utilização para o usuário. 
Uma breve descrição para cada ViewController está descrita a seguir:


\textbf{RouteMenuViewController:} View Controller que exibe uma lista de opções para o usuário. Para o caso de se selecionar o endereço de destino a classe exibe as opções entrar com endereço ou utilizar da lista de favoritos. Para o caso de se selecionar o endereço de origem ela exibe além das opções disponíveis no caso de endereço destino, a opção de se utilizar o endereço atual do dispositivo.
A implementação para obtenção do endereço atual utilizou-se da classe \emph{MKReverseGeocode}, que a partir da posição em relação a latitude e longitude do local, faz a chamada para o serviço de rastreamento de endereço da API do Google Maps, obtendo assim o endereço completo que existe naquele ponto.

\begin{figure}[htpb]
	\centering
	\includegraphics[scale=0.2]{img/iphone/Destino.png}
	\includegraphics[scale=0.2]{img/iphone/Origem.png}
	\caption{Aplicação na tela de seleção de menu de endereços}
\end{figure}

Uma descrição das principais classes utilizadas para esse módulo encontra-se abaixo:
\textbf{AddressViewController:} Classe que oferece a interface para o usuário digitar o endereço. Exibe uma lista do histórico da aplicação, que pode ser utilizada sem a necessidade de digitar novamente o endereço já usado.
% \begin{figure}
% 	\centering
% 	\includegraphics[scale=0.2]{img/iphone/AddressViewController.png}
% 	\caption{Aplicação na tela de inclusão de endereço}
% \end{figure}

\textbf{FavoriteListViewController:} Classe que exibe a lista de favoritos salvos pelo usuário. Pode-se excluir da lista arrastando o dedo encima do endereço favorito salvo, e confirmar a exclusão com o botão que aparece na tela.

% \begin{figure}[htpb]
% 	\centering
% 	\includegraphics[scale=0.2]{img/iphone/FavoriteListViewController.png}
% 	\caption{Aplicação na lista de favoritos}
% \end{figure}

\textbf{SearchViewController:}
Classe que apresenta a tela que exibe informações do endereço encontrado a partir da requisição do usuário. Possui o endereço completo encontrado e um mapa para identificar a redondeza do local. O usuário possui as opcões de salvar no favorito, enviar via e-mail e confirmar o endereço.

\begin{figure}[htpb]
	\centering
	\includegraphics[scale=0.2]{img/iphone/SearchViewController.png}
	\caption{Aplicação exibindo detalhes do endereço}
\end{figure}

Métodos de requisição de rotas é realizado a partir da requisição das posições de endereço de destino e origem no servidor. O servidor processa o pedido, e a partir dos dados da situação de trânsito, manipula o trajeto para evitar congestionamento para melhorar a performance no tempo na viagem do usuário. Nas figuras abaixo, encontram-se os códigos usado para a requisição no servidor, e o tratamento de sua resposta.


\textbf{FavoriteAddViewController:} View Controller com formulário para a entrada no nome do endereço favorito a ser adicionado.


\textbf{MFMailComposeViewControlle:} Classe auxiliar para o envio via e-mail. O corpo do e-mail é pre-formatado com o endereço do local entrado pelo usuário.

\textbf{RouteRecalculatorClock:} Para o caso do uso da posição atual do usuário no endereço de origem, a Classe objeto RouteRecalculatorClock é ativada. A cada 10 segundos é conferida a distância entre o usuário e a rota definida, e caso for maior que 50 metros uma nova requisição de rota é enviada, atualizando o trajeto para a posição original do usuário naquele momento.

\textbf{RoutePolyline:} Classe objeto que possui uma lista de pontos para desenho da rota no mapa.


% subsubsection módulo_de_geração_de_rota (end)

%
%~~
%~~ Módulo de trânsito
%~~
%

\subsubsection{Módulo de trânsito} % (fold)
\label{ssub:módulo_de_trânsito}

Para implementação do módulo de trânsito é utilizado um método para chamadas contínuas de requisições no servidor para adquirir informações sobre a malha de tráfego nas redondezas que o usuário está visualizando. A malha é desenhada como se fosse uma lista de trajetos a serem desenhadas no mapa. A via é colorida a partir da informação da cor a ser renderizada para a via no dado de retorno da requisíção.
Uma listagem das principais classes para este módulo encontra-se a seguir:

\textbf{RegisterClock:} Objeto que envia a identificação, posição e velocidade do usuário a cada 3 segundos. Inicialmente definimos que o tempo do momento que o registro é disparado era também enviado para o servidor. Porém não tinhamos levado em consideração que cada aparelho poderia ter horários diferentes, invalidando os dados no servidor. Para solucionar este problema, o servidor ficou responsável por guardar o horário de recebimento do registro.
Um outro problema de integridade dos dados surgiu, pois dependendo da condição de conexão de internet do dispositivo tiveram casos em que mais de uma requisição de registro era realizada ao mesmo tempo. Cada requisição possuia dados de velocidade diferentes, mas com exatamente o mesmo tempo. Com uma política de envio sincromo dos dados do registro solucionamos este problema, tendo agora a diferença de 3 segundos entre requisições com contato com sucesso ao servidor.

\textbf{TrafficClock:} Objeto que realiza a rotina de atualização da malha de tráfego a cada 30 segundos. Ao movimentar o mapa, faz a requisição automática para extender a malha de tráfego para a região em visualização.

\textbf{TrafficPolyline:} Classe objeto que possui uma lista de pontos para desenho da malha de transito no mapa. Para cada TrafficPolyline é definido uma cor para sua linha, representando as condições do tráfego na região marcada.

% subsubsection módulo_de_trânsito (end)

%
%~~
%~~ Módulo de eventos
%~~
%

\subsubsection{Módulo de eventos} % (fold)
\label{ssub:módulo_de_eventos}

O módulo de eventos contém classes que coordenam os métodos para gerenciar os eventos. Contém uma rotina de requisição da lista de eventos com o servidor que é atualizado a cada 10 segundos, e relacionado com o nível de zoom que o usuário está visualizando no mapa. Dependendo da resposta do servidor novas marcações no mapa de eventos são criados ou removidos. 
Para marcação de um novo evento, é possível definir entre 4 tipos: polícia, trânsito, acidente e aviso. O usuário pode colocar uma breve descrição e foto para complementar as informações do evento a ser divulgado. 
Para salvar e disponibilizar a foto, foi realizado um redimensionamento e compressão para que não consuma muita banda de internet do dispositivo. Houveram dificuldades no gerenciamento de memória para realizar este tratamento da foto, sendo necessário um grande esforço de organização de alocação de memória do dispositivo.
As principais classes utilizadas neste módulo estão listadas a seguir:


\textbf{EventClock:} Classe que opera esporadicamente a requisição da lista de eventos no servidor. Entre uma requisição e outra foi definido 8 segundos de espera. Também é responsável por tratar a resposta do servidor.

\begin{figure}[htpb]
	\centering
	\includegraphics[scale=0.2]{img/iphone/EventoMapa.png}
	\caption{Evento identificado no mapa}
\end{figure}

\textbf{EventListViewController:} View Controller que dispõe para o usuário a escolha de que tipo de evento ele quer criar. Há as opções de ``Polícia'', ``Trânsito'', ``Acidente'' e ``Aviso''.

\textbf{EventDetailsViewController:} Classe que disponibiliza a criação do tipo do evento selecionado anteriormente pelo EventListViewController. Há espaço para uma descrição e uma foto para uma melhor representação do evento identificado.

\textbf{EventAnnotation:} Classe objeto de uma anotação que pode ser adicionada no mapa principal da aplicação.

 

% subsubsection módulo_de_eventos (end)

% subsection aplicativo_móvel (end)

% section implementação (end)
