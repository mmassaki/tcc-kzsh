%
%~~
%~~ Desenvolvimento
%~~
%


\chapter{Desenvolvimento}
\label{chp:desenvolvimento}

O desenvolvimento do sistema foi dividido em duas partes principais: aplicação do servidor e aplicativo móvel para iPhone. As duas partes foram desenvolvidas paralelamente por cada integrante do grupo e foram realizados testes para cada funcionalidade desenvolvida. Foram especificadas interfaces de comunicação entre o servidor e o dispositivo móvel afim de padronizar e estabelecer as trocas de informações entre ambos. 

Neste capítulo são descritos separadamente os procedimentos executados para implementação de cada parte do projeto (servidor e aplicativo móvel) com seus respectivos códigos-fonte. Inicialmente é apresentada a implementação referente ao servidor separada por funcionalidades e por último é explicado a implementação em maiores detalhes do aplicativo móvel construído na plataforma \emph{iOS} e os componentes utilizados.

\section{Servidor}
\label{sec:servidor}

Para que o desenvolvimento fosse mais ágil, utilizou-se o \emph{Scaffolding} do \emph{Rails}. O \emph{Scaffolding} gera toda a parte de CRUD dos objetos, inclusive o \emph{script} de criação de tabela no banco de dados, utilizando-se o \emph{WebService} \emph{RESTful} para acesso, criação e edição dos dados.

Foi registrado um domínio gratuito no site \url{http://www.co.cc/} com o nome \url{betterwayserver.co.cc} e foi contratado um plano de hospedagem de \emph{site} nos servidores da empresa TeHospedo: serviços de internet \cite{TeHospedo:site}.

\subsubsection{Criação de eventos} % (fold)
\label{ssub:criação_de_eventos}

Os eventos do trânsito são criados pelo usuário através do aplicativo móvel. O servidor tem o papel de receber as informações do novo evento e armazená-las no banco de dados.

Ao criar um recurso no \emph{Scaffolding} são geradas as classes do \emph{model} do recurso e seu \emph{controller} para acesso via requisições HTTP. A classe EventosController 

% subsubsection criação_de_eventos (end)

\subsubsection{Temporização do evento} % (fold)
\label{ssub:temporização_do_evento}

Os eventos informados pelos usuários são exibidos durante 30 minutos. Após esse período eles são marcados como inativos no banco de dados, não sendo mais informados pelo servidor.

Para a implementação da atualização dos registros no banco de dados utilizou-se o ``crontab'' do servidor. O ``crontab'' é um utilitário dos sistemas Unix e Solaris que permite a execução de comandos (tarefas) em \emph{background} a cada intervalo de tempo especificado.

Criou-se então, uma tarefa que atualiza o banco de dados inativando os eventos que ultrapassarem 30 minutos a partir do horário em que foram informados. Essa tarefa é executada a cada cinco minutos no servidor para que não haja sobrecarga no mesmo e pode ser vista a seguir.
\\

\begin{lstlisting}
0,5,10,15,20,25,30,35,40,45,50,55 * * * * cd ~/better_way && rails runner -e production app/cron/atualizar_eventos.rb
\end{lstlisting}

Basicamente a tarefa é executada quando os minutos do horário do servidor forem múltiplos de cinco utilizando o \emph{runner} do ambiente \emph{rails} em produção para executar o código \emph{Ruby} atualizar\_eventos.rb que é descrito a seguir.
\\

\begin{lstlisting}[language=Ruby]
	class AtualizarEventos < ActiveRecord::Base

	  Evento.update_all({:ativo => false}, ["ativo = 1 AND data_hora < ?", Time.now - 30.minutes])

	end
\end{lstlisting}

% subsubsection temporização_do_evento (end)

% subsection eventos (end)

\subsection{Registros} % (fold)
\label{sub:registros}


% subsection registros (end)

\subsection{Rotas} % (fold)
\label{sub:rotas}


% subsection rotas (end)

\subsection{Trânsito} % (fold)
\label{sub:trânsito}


% subsection trânsito (end)

% section servidor (end)

\section{Aplicativo móvel} % (fold)
\label{sec:aplicativo_móvel}

A aplicação \emph{BetterWay} construída para o ambiente \emph{iOS} é o componente principal do projeto, tendo como objetivo controlar a requisição de rota para o usuário e da visualização da malha da situação de trânsito no mapa. Nesse contexto, todas as lógicas de visualização do trânsito estão contidos nesse módulo. Contém rotinas para envio constante de dados do usuário sobre sua posição e velocidade e também é responsável pelo envio de eventos e gerenciamento de endereços.


\subsection{Dificuldades iniciais}
\label{ssub:dificuldades_iniciais}
As dificuldades de construir a aplicação \emph{BetterWay} para o dispositivo iPhone vem do momento de sua criação, uma vez que o grupo não possui o conhecimento sobre o \emph{framework} de mapas e de requisições web. 
No estudo do \emph{framework} de mapas para o \emph{Cocoa Touch}, chamado \emph{MapKit}, não existia métodos diretos para desenho de rotas e de camadas auxiliares para uma camada de desenho na visualização do mapa. Implementamos métodos indiretos para desenho através do \emph{framework} \emph{CoreGraphics} que deixava a aplicação sobrecarregada, pois neste método era necessário a recalculação de todas marcações realizadas no mapa a cada transição de movimento.
Porém com o lançamento do SDK 4.0 no final do mês de Agosto melhorias foram implementadas no \emph{framework MapKit}, sendo agora possível a implementação de uma camada gráfica encima do mapa. A partir do estudo dessa camada, conseguimos implementar uma solução mais dinâmica onde já não era mais ncessário o recalculo de todas marcações para cada mudança no mapa.



\subsection{Bibliotecas utilizadas}
Para a aplicação no dispositivo iPhone, utiliza-se duas bibliotecas auxiliares na implementação.

\textbf{\emph{JSON}:} Biblioteca de codificação/decodificação do protocolo padrão \emph{JSON} para leitura como dados para a linguagem \emph{Objetive-C}. Protocolo \emph{JSON} é utilizado como interface de comunicação entre o dispositivo móvel e o servidor.

\textbf{\emph{ASIHTTPRequest}:} Biblioteca auxiliar para envio de requisições web nas utilizações \emph{GET}, \emph{POST}, \emph{UPDATE} e \emph{DELETE}. Realiza os procedimentos de verificação e delegação dos métodos existentes no \emph{Objetive-C}.




\subsection{Classe delegadora: \emph{MapDirection}}

Classe Delegadora principal da aplicação. Responsável por informar sobre a condições e informações básicas do aparelho e de coordenar todas as View Controllers do aplicativo, além de ser o responsável por manter as listas de permanências de dados sobre os últimos endereços usados e endereços favoritos.



Os dados a serem armazenados são manipulados pela classe NSUsersDefault, que guarda no SandBox da aplicação. Ao iniciar a aplicação, o método loadDatabase é chamado. Ao encerrar a aplicação, a classe delegate captura essa notificação e assim o processo se retenção de dados é realizada.

\begin{figure}
	\centering
	\includegraphics[scale=0.8]{img/iphone/appWillTerminate.png}
	\caption{Método de encerramento da aplicação.}
\end{figure}



\textbf{Reachability:} Para o verificamento de conectividade do aparelho, implementou-se uma classe herdada de \emph{SCNetworkReachability}, disponibilizada pela Apple a partir do \emph{SystemConfiguration.framework}. Verifica-se a conexão com a internet via \emph{edge}/\emph{3G} ou \emph{wifi}. O método aplicado é descrito a seguir:



\begin{lstlisting}[language=Objetive-C]
- (void) checkNetworkStatus:(NSNotification *)notice {
	// called after network status changes
	NetworkStatus internetStatus = [internetReachable currentReachabilityStatus];
	switch (internetStatus) {
		case NotReachable: {
			NSLog(@"The internet is down.");
			self._internetActive = NO;
			break;
		}
		case ReachableViaWiFi: {
			NSLog(@"The internet is working via WIFI.");
			self._internetActive = YES;
			break;
		}
		case ReachableViaWWAN: {
			NSLog(@"The internet is working via WWAN.");
			self._internetActive = YES;
			break;
		}
	}
}
\end{lstlisting}



Possui objetos que verificam de tempo em tempo diversos atributos do aparelho:
\textbf{CLLocationManager:} Classe disponibilizada pela Apple que faz a verificação da disponibilidade do GPS. Possui diversos métodos de utilização do GPS, entre elas o método de buscar a posição atual do usuário.



\subsection{View Controller Principal: \emph{BetterWayViewController}} % (fold)
\label{sec:betterwayviewcontroller}

Esta sessão contém a descrição da classe central da aplicação, sendo o responsável pela tela principal. Possui o mapa onde é identificado as funcionalidades de geração de rotas, informação do trânsito e de eventos para o usuário. Possui o \emph{UINavigatorController}, que conecta todas as telas da aplicação.


\subsection{Módulo de geração de rota} % (fold)
\label{sec:moduloRota}

Este módulo foi estruturada diversas View Controllers necessárias para o fluxo de interatividade com o usuário, que entra com os dados da via de destino e origem no aparelho a fim de gerar uma rota evitando os congestionamentos conhecidos pelo servidor.

A seguir é apresentada o diagrama de classe para a geração de rota na aplicação. Foi definido de tal maneira recursiva para o reaproveitamento das mesmas classes, sendo que ao passar o endereço de destino e o de origem, o usuário passe pelas mesmas telas. Decidimos por implementar algumas funcionalidades auxiliares como um armazenamento de endereços como um histórico e como uma lista favoritos, para uma melhor experiência de utilização para o usuário. 


\begin{figure}
	\centering
	\includegraphics[scale=0.2]{img/iphone/BetterWayDiagramaClasseRota.pdf}
	\caption{Diagrama de classe para o módulo de geração de rota}
\end{figure}



Uma breve descrição para cada ViewController a seguir:
\textbf{RouteMenuViewController:} View Controller que exibe uma lista de opções para o usuário. Para o caso de se selecionar o endereço de destino a classe exibe as opções entrar com endereço ou utilizar da lista de favoritos. Para o caso de se selecionar o endereço de origem ela exibe além das opções disponíveis no caso de endereço destino, a opção de se utilizar o endereço atual do dispositivo.
A implementação para o uso do endereço atual utilizou-se da classe \emph{MKReverseGeocode}, que a partir da posição em relação a latitude e longitude do local, utiliza-se o serviço de rastreamento de endereço da API do Google Maps.
\begin{figure}
	\centering
	\includegraphics[scale=0.2]{img/iphone/Destino.png}
	\includegraphics[scale=0.2]{img/iphone/Origem.png}
	\caption{Aplicação na tela de seleção de menu de endereços}
\end{figure}


\textbf{AddressViewController:} Classe que oferece a interface para o usuário digitar o endereço. Exibe uma lista do histórico da aplicação, que pode ser utilizada sem a necessidade de digitar novamente o endereço já usado.
\begin{figure}
	\centering
	\includegraphics[scale=0.2]{img/iphone/AddressViewController.png}
	\caption{Aplicação na tela de inclusão de endereço}
\end{figure}

\textbf{FavoriteListViewController:} Classe que exibe a lista de favoritos salvos pelo usuário. Pode-se excluir da lista arrastando o dedo encima do endereço favorito salvo, e confirmar a exclusão com o botão que aparece na tela.
\begin{figure}
	\centering
	\includegraphics[scale=0.2]{img/iphone/FavoriteListViewController.png}
	\caption{Aplicação na lista de favoritos}
\end{figure}



\textbf{SearchViewController:}
Classe que apresenta a tela que exibe informações do endereço encontrado a partir da requisição do usuário. Possui o endereço completo encontrado e um mapa para identificar a redondeza do local. O usuário possui as opcões de salvar no favorito, enviar via e-mail e confirmar o endereço.
\begin{figure}
	\centering
	\includegraphics[scale=0.2]{img/iphone/SearchViewController.png}
	\caption{Aplicação exibindo detalhes do endereço}
\end{figure}


Métodos de requisição de rotas é realizado a partir da requisição das posições de endereço de destino e origem no servidor. O servidor processa o pedido, e a partir dos dados da situação de trânsito, manipula o trajeto para evitar congestionamento para melhorar a performance no tempo na viagem do usuário. Nas figuras abaixo, encontram-se os códigos usado para a requisição no servidor, e o tratamento de sua resposta. O método de requisição está descrito abaixo:


\begin{lstlisting}[language=Objetive-C]
- (void)requestRouteWithDestinationAddress:(AddressLocation *)toDestination withOrigin:(AddressLocation *)toOrigin {
	NSString *requestString = [NSString stringWithFormat:@"%@/rota/tracar?origem=%f,%f&destino=%f,%f", 
							   SERVER_URL,
							   toOrigin.coordinate.latitude,
							   toOrigin.coordinate.longitude,
							   toDestination.coordinate.latitude,
							   toDestination.coordinate.longitude];
	NSURL *url = [NSURL URLWithString:requestString];
	ASIFormDataRequest *request = [ASIFormDataRequest requestWithURL:url];
	[request setDelegate:self];
	[request setDidFinishSelector:@selector(requestDone:)];
	[request setDidFailSelector:@selector(requestWentWrong:)];
	[request addRequestHeader:@"User-Agent" value:@"BetterWayv1.0"];	
	[request setRequestMethod:@"GET"];	
	[request startAsynchronous];
}
\end{lstlisting}

\begin{figure}
	\centering
	\includegraphics[scale=0.6]{img/iphone/coreRotaResponse.png}
	\caption{Tratamento da resposta de requisição de rota}
\end{figure}


Classes para as funções suplementares da aplicação:
\textbf{FavoriteAddViewController:} View Controller com formulário para a entrada no nome do endereço favorito a ser adicionado.


\textbf{SendDestinationViewController:} Classe auxiliar para o envio via e-mail do endereço selecionado pelo usuário. Utiliza-se a classe MFMailComposeViewController disponibilizado pela Apple.

\textbf{RouteRecalculatorClock:} Para o caso do uso da posição atual do usuário no endereço de origem, a Classe objeto RouteRecalculatorClock é ativada. A cada 10 segundos é conferida a distância entre o usuário e a rota definida, e caso for maior que 50 metros uma nova requisição de rota é enviada, atualizando o trajeto para a posição original do usuário naquele momento.



\subsection{Módulo de trânsito} % (fold)
\label{sec:moduloTransito}

Para implementação do módulo de trânsito é utilizado um método para chamadas contínuas de requisições no servidor para adquirir informações sobre a malha de tráfego nas redondezas que o usuário está visualizando. A malha é desenhada como se fosse uma lista de trajetos a serem desenhadas no mapa. A via é colorida a partir da informação da cor a ser renderizada para a via no dado de retorno da requisíção.


\textbf{TrafficClock:} Objeto que realiza a rotina de atualização da malha de tráfego a cada 30 segundos. Ao movimentar o mapa, faz a requisição automática para extender a malha de tráfego para a região em visualização.

\textbf{RegisterClock:} Objeto que envia a identificação, posição e velocidade do usuário a cada 3 segundos. Inicialmente definimos que o tempo do momento que o registro é disparado era também enviado para o servidor. Porém não tinhamos levado em consideração que cada aparelho poderia ter horários diferentes, invalidando os dados no servidor. Para solucionar este problema, o servidor ficou responsável por guardar o horário de recebimento do registro.
Um outro problema de integridade dos dados surgiu, pois dependendo da condição de conexão de internet do dispositivo tiveram casos em que mais de uma requisição de registro era realizada ao mesmo tempo. Cada requisição possuia dados de velocidade diferentes, mas com exatamente o mesmo tempo. Com uma política de envio sincromo dos dados do registro solucionamos este problema, tendo agora a diferença de 3 segundos entre requisições com contato com sucesso ao servidor.


\subsection{Módulo de eventos} % (fold)
\label{sec:moduloEventos}

O módulo de eventos contém classes que coordenam os métodos para gerenciar os eventos. Contém uma rotina de requisição da lista de eventos com o servidor que é atualizado a cada 10 segundos, e relacionado com o nível de zoom que o usuário está visualizando no mapa. Dependendo da resposta do servidor novas marcações no mapa de eventos são criados ou removidos.

\textbf{EventClock:} Classe que opera esporadicamente a requisição da lista de eventos no servidor. Entre uma requisição e outra foi definido 8 segundos de espera. Também é responsável por tratar a resposta do servidor.


\begin{figure}
	\centering
	\includegraphics[scale=0.2]{img/iphone/EventoMapa.png}
	\caption{Evento identificado no mapa}
\end{figure}




Para criar um novo evento na posição atual do dispositivo, seleciona-se ``+ Evento'' na tela principal.
\textbf{EventListViewController:} View Controller que dispõe para o usuário a escolha de que tipo de evento ele quer criar. Há as opções de ``Polícia'', ``Trânsito'', ``Acidente'' e ``Aviso''.

\textbf{EventDetailsViewController:} Classe que disponibiliza a criação do tipo do evento selecionado anteriormente pelo EventListViewController. Há espaço para uma descrição e uma foto para uma melhor representação do evento identificado.









% section trânsito (end)

% section aplicativo_móvel (end)
