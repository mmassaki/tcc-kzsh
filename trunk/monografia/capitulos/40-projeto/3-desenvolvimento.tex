%
%~~
%~~ Implementação
%~~
%
\section{Implementação} % (fold)
\label{sec:implementação}

A implementação do sistema foi dividida em duas partes principais: aplicação do servidor e aplicativo móvel para iPhone. Cada integrante do grupo implementou uma das partes paralelamente e foram realizados testes para cada funcionalidade desenvolvida. Foram especificadas interfaces de comunicação entre o servidor e o dispositivo móvel afim de padronizar e estabelecer as trocas de informações entre ambos. 

Neste capítulo são descritos separadamente os procedimentos executados para implementação de cada parte do projeto (servidor e aplicativo móvel). Inicialmente é apresentada a implementação referente ao servidor separada por funcionalidades e por último é explicado a implementação em maiores detalhes do aplicativo móvel construído na plataforma \emph{iOS} e os componentes utilizados.

%
%~~
%~~ Servidor
%~~
%

\subsection{Servidor} % (fold)
\label{sub:servidor}

Para que o desenvolvimento fosse ágil, utilizou-se o \emph{Scaffolding} do \emph{Rails}. O \emph{Scaffolding} gera toda a parte de CRUD dos objetos, inclusive o \emph{script} de criação de tabela no banco de dados, utilizando-se o \emph{WebService} \emph{RESTful} para acesso, criação e edição dos dados.

Foi registrado o domínio gratuito \url{betterwayserver.co.cc} no site \url{http://www.co.cc/} e foi contratado um plano de hospedagem de \emph{site} nos servidores da empresa TeHospedo: serviços de internet \cite{TeHospedo:site}, que fornece hospedagem \emph{Linux} para aplicações \emph{Ruby on Rails}.


\subsubsection{Dificuldades iniciais} % (fold)
\label{ssub:dificuldades_iniciais_servidor}

Como o ambiente \emph{Ruby on Rails} já era de conhecimento do grupo, não foi difícil a criação da aplicação inicialmente, pois o ambiente já está bem estruturado para a criação dos métodos de CRUD e uso de \emph{web services} utilizando \emph{RESTful}.

Foi necessário o estudo das \emph{Google Maps APIs} disponíveis afim de se escolher a melhor alternativa para o projeto. Inicialmente optou-se pela API via \emph{web services}, pois ela fornece dados diretos via requisições HTTP. Testou-se a API via \emph{web services} e achou-se que ela não informava as coordenadas dos pontos da rota requerida, dados necessários para o desenho da rota. Uma alternativa era utilizar a API \emph{JavaScript} que informava explicitamente as coordenadas dos pontos da rota, mas seria muito custosa sua implementação.

Um estudo mais aprofundado nos dados retornados pela API via \emph{web services} permitiu a descoberta de que as coordenadas necessárias são enviadas de forma codificada de forma que o dado fique mais compacto diminuindo a quantidade de dados transferidos. Dessa forma optou-se definitivamente pela API via \emph{web services} e foi encontrada na internet uma biblioteca para \emph{Ruby} que faz a decodificação dos dados para coordenadas geográficas.

Outra dificuldade encontrada foi encontrar uma maneira de atualizar os dados do banco de dados, pois os dados de eventos e trânsito devem ser inativados após trinta minutos. Buscou-se informações de como implementar tarefas rotineiras em \emph{Ruby on Rails} e descobriu-se que uma maneira é utilizar o utilitário \emph{crontab} que está disponível para os sistemas operacionais baseados em \emph{UNIX} e \emph{Solaris}.

O mapeamento do trânsito foi a tarefa mais complicada inicialmente, pois o grupo não possui conhecimento na área de tráfego. As informações coletadas pelos dispositivos \emph{iPhones} são basicamente a coordenada e velocidade atual do usuário e, a partir disto deve-se mapear o trânsito. Buscou-se por alguma banco de dados que fornecesse as coordenadas das ruas da cidade de São Paulo, porém não obteve-se sucesso.

Uma alternativa foi utilizar o serviço de geocodificação reversa do \emph{Google}, que ao informar uma coordenada retorna um trecho de endereço, geralmente um quarteirão da rua. Com isso pode-se mapear o trânsito sem muitas dificuldades.

% subsubsection dificuldades_iniciais (end)

%
%~~
%~~ Cadastro de eventos
%~~
%

\subsubsection{Cadastro de eventos} % (fold)
\label{ssub:cadastro_de_eventos}

Os eventos do trânsito são criados pelo usuário através do aplicativo móvel. O servidor tem o papel de receber as informações do novo evento e armazená-las no banco de dados.

Ao criar um recurso no \emph{Scaffolding} são geradas as classes do \emph{model} do recurso e seu \emph{controller} para acesso via requisições HTTP. Para criação de um novo evento é necessário o envio de um POST para o endereço \url{http://betterwayserver.co.cc/eventos} com as informações do novo evento nos parâmetros da requisição. O método \emph{create} da classe \emph{EventosController} é encarregada de tratar essas requisições.

O horário de criação do evento é obtido do relógio do servidor para evitar que o usuário envie informação errada, pois o horário do dispositivo pode ser configurado manualmente.

O arquivo de imagem do evento é obtido via POST \emph{multipart/form-data} e os dados binário da imagem são armazenados diretamente no banco de dados. Este método de envio é o mesmo utilizado em páginas HTML que utilizam formulários que necessitam de \emph{upload} de arquivo.

% subsubsection criação_de_eventos (end)

%
%~~
%~~ Consulta de eventos
%~~
%

\subsubsection{Consulta de eventos} % (fold)
\label{ssub:consulta_de_eventos}

O servidor deve fornecer as informações dos eventos atuais aos usuários. Para isso o aplicativo móvel pode acessar os dados dos eventos através de um GET no endereço \url{http://betterwayserver.co.cc/eventos} de duas maneiras:

\begin{enumerate}
	\item \textbf{Eventos localizados:}
	
	O servidor envia somente eventos próximos à coordenada informada pelo usuário. O cliente deve informar uma coordenada através dos parâmetros \emph{latitude} e \emph{longitude} e, opcionalmente, uma área de abrangência através dos parâmetros \emph{delta\_latitude} e \emph{delta\_longitude}.
	
	\item \textbf{Todos eventos:}
	
	O servidor envia todos os eventos armazenados em seu banco de dados. Para acessar todos os eventos, basta o cliente requisitar o endereço através de um GET sem informar as coordenadas geográficas.
	
\end{enumerate}

Esta requisição é tratada pelo método \emph{index} da classe \emph{EventosController}.

% subsubsection consulta_de_eventos (end)

%
%~~
%~~ Consulta de eventos
%~~
%

\subsubsection{Temporização do evento} % (fold)
\label{ssub:temporização_do_evento}

Os eventos informados pelos usuários são exibidos durante 30 minutos. Após esse período eles são marcados como inativos no banco de dados, não sendo mais informados pelo servidor.

Para a implementação da atualização dos registros no banco de dados utilizou-se o \emph{crontab} do servidor. O \emph{crontab} é um utilitário dos sistemas \emph{Unix} e \emph{Solaris} que permite a execução de comandos (tarefas) em \emph{background} a cada intervalo de tempo especificado.

Criou-se então, uma tarefa que atualiza o banco de dados inativando os eventos que ultrapassarem 30 minutos a partir do horário em que foram informados. Essa tarefa é executada a cada cinco minutos no servidor para que não haja sobrecarga no mesmo.

% subsubsection temporização_do_evento (end)

%
%~~
%~~ Criação de registros
%~~
%

\subsubsection{Cadastro de registros} % (fold)
\label{ssub:cadastro_de_registros}

Os registros são dados armazenados no servidor para interpretação da situação do tráfego nas ruas em que os usuários do sistema viajam. O dispositivo móvel envia de tempos em tempos as informações de posição, velocidade e identificação do mesmo. Essas informações são armazenadas no banco de dados do servidor, que posteriormente analisa-as e estima o trânsito em determinadas vias.

O envio do registro é feito através de um POST para o endereço \url{betterwayserver.co.cc/registros} e o método \emph{create} da classe \emph{RegistrosController} é o responsável por manipular essas requisições.

O horário de envio é obtido pelo relógio do servidor pelo mesmo motivo citado anteriormente - evitar erro de informação já que o usuário pode ajustar manualmente o horário do dispositivo móvel.

Após a criação do registro, dispara-se uma \emph{thread} que busca o endereço referente à coordenada informada, armazena-o no banco de dados e faz uma chamada para a classe \emph{TransitoController} para que ela atualize as informações de trânsito utilizando o novo registro.

% subsubsection criação_de_registros (end)

%
%~~
%~~ Traças rota
%~~
%

\subsubsection{Traças rota} % (fold)
\label{ssub:traçar_rota}

O servidor é responsável pela geração de rotas para os dispositivos móveis do sistema. Como a criação de rotas está fora do escopo do trabalho proposto, foi utilizada a API do \emph{Google Maps}, via \emph{Webservices}, para geração de rotas entre dois pontos.

O procedimento de criação de rota segue o seguinte fluxo:
\begin{enumerate}
	\item O usuário, ao solicitar uma rota, dispara uma requisição HTTP ao servidor informando as coordenadas de origem e destino da rota desejada.
	\item O servidor recebe essa requisição e dispara uma nova requisição para a API do \emph{Google Maps} solicitando rotas entre as duas coordenadas informadas pelo usuário.
	\item A API do \emph{Google Maps} retorna rotas para o servidor estruturada em formato JSON.
	\item O servidor interpreta as rotas, verificando se há algum trecho em que há problemas de fluidez, de acordo com as informações armazenadas no seu banco de dados.
	\item O servidor retorna ao usuário a rota que não encontrar problemas de fluidez em formato estruturado JSON.
\end{enumerate}

A classe \emph{RotaController}, responsável por este procedimento de criação de rotas no servidor.

A API do \emph{Google Maps} utilizada envia os dados com o desenho da rota (\emph{polyline}) de forma codificada. O algoritmo de codificação é disponibilizado pelo \emph{Google} em \cite{Google:MapsAPI:EncodedPolyline}. Para que a rota seja desenhada corretamente no dispositivo móvel, é necessário fazer a descodificação dessa informação para coordenadas geográficas. Esta descodificação é realizada no servidor antes de enviar as informações para o cliente através do uso da biblioteca \emph{polyline\_decoder} \cite{PolylineDecoder}.

% subsubsection criação_de_rotas (end)

%
%~~
%~~ Mapeamento do trânsito
%~~
%

\subsubsection{Mapeamento do trânsito} % (fold)
\label{ssub:mapeamento_do_trânsito}

O servidor deve, através das informações obtidas dos usuários nos registros, mapear o trânsito nas vias por onde os usuários trafegaram. Para que não hajam informações incorretas no mapeamento, foi estabelecida a seguinte premissa:

\begin{itemize}
	\item Para que as informações de registros tornem-se informações de trânsito para o usuário, são necessários pelo menos cinco usuários informando a mesma situação, ou seja, é necessário que pelo menos cinco usuários trafeguem pela mesma via em tempos próximos informando velocidades compatíveis.
\end{itemize}

Para armazenar a informação de trânsito é necessário armazenar um trecho de via com a informação de intensidade do trânsito. O servidor armazena duas coordenadas (ponto inicial e final), a intensidade, em escala numérica e, a \emph{polyline} do trecho, que são as coordenadas para desenho no mapa.

Para implementação desta funções utilizou-se o serviço de geocodificação reversa do \emph{Google}. Este serviço converte uma coordenada em um trecho de endereço. Por exemplo a coordenada (-23.566623, -46.650181) é convertida para ``Av. Paulista, 521-811 - Bela Vista, Sao Paulo - São Paulo, 01311-100, Brazil''.

Dessa forma é possível obter as duas coordenadas do endereço utilizando o serviço de geocodificação do \emph{Google} e a \emph{polyline} do trecho utilizando o serviço de rotas também do \emph{Google}.

Da mesma forma que os eventos, as informações de trânsito ficam ativas apenas por 30 minutos. Caso não seja atualizada a informação dentro desse tempo ela deve ser inativada. Para isso inclui-se na mesma tarefa de atualização da tabela de eventos, um \emph{script} de atualização da tabela de trânsito.

% subsubsection mapeamento_do_trânsito (end)

% subsection servidor (end)


%
%~~
%~~ Aplicativo móvel
%~~
%

\subsection{Aplicativo móvel} % (fold)
\label{sub:aplicativo_móvel}

A aplicação \emph{BetterWay} construída para o ambiente \emph{iOS} é o componente principal do projeto, tendo como objetivo controlar a requisição de rota para o usuário e da visualização da malha da situação de trânsito no mapa. Nesse contexto, todas as lógicas de visualização do trânsito estão contidos nesse módulo. Contém rotinas para envio constante de dados do usuário sobre sua posição e velocidade e também é responsável pelo envio de eventos e gerenciamento de endereços.

Um modelo de diagrama de classes simplificado da aplicação e o diagrama de navegação são apresentados na seção~\ref{sec:modelo_de_classes} do apêndice~\ref{cha:especificação_de_requisitos_do_sistema} e na seção~\ref{sec:protótipo_de_navegação} do apêndice~\ref{cha:projeto_da_interface_de_usuário} , respectivamente.
 

%
%~~
%~~ Dificuldades iniciais
%~~
%

\subsubsection{Dificuldades iniciais} % (fold)
\label{ssub:dificuldades_iniciais}

As dificuldades para construção da aplicação \emph{BetterWay} para o dispositivo iPhone ocorreram do momento de sua criação, uma vez que o grupo não possuía conhecimento sobre o \emph{framework} de mapas e de requisições \emph{web}.

No \emph{framework} de mapas para o \emph{Cocoa Touch}, chamado \emph{MapKit}, não existiam métodos diretos para desenho de rotas e de camadas auxiliares para uma camada de desenho na visualização do mapa. Foram implementados métodos indiretos para desenho através do \emph{framework} \emph{CoreGraphics}, o que deixava a aplicação sobrecarregada, pois com este método era necessário o recálculo de todas as marcações realizadas no mapa a cada transição de movimento.

Porém com o lançamento do SDK 4.0 no final do mês de Agosto algumas melhorias foram implementadas no \emph{framework MapKit}, sendo possível a implementação de uma camada gráfica em cima do mapa. A partir do estudo dessa camada, conseguiu-se implementar uma solução mais dinâmica onde já não era mais necessário o recálculo de todas marcações para cada mudança no mapa.

% subsubsection dificuldades_iniciais (end)


%
%~~
%~~ Bibliotecas utilizadas
%~~
%

\subsubsection{Bibliotecas utilizadas} % (fold)
\label{ssub:bibliotecas_utilizadas}

Para a aplicação no dispositivo iPhone, utilizam-se duas bibliotecas auxiliares na implementação.

\textbf{\emph{JSON}:} Biblioteca de codificação/decodificação do protocolo padrão \emph{JSON} para leitura como dados para a linguagem \emph{Objetive-C}. Protocolo \emph{JSON} é utilizado como interface de comunicação entre o dispositivo móvel e o servidor. \cite{json-framework}

\textbf{\emph{ASIHTTPRequest}:} Biblioteca auxiliar para envio de requisições web nas utilizações \emph{GET}, \emph{POST}, \emph{UPDATE} e \emph{DELETE}. Realiza os procedimentos de verificação e delegação dos métodos existentes no \emph{Objetive-C}. \cite{ASIHTTPRequest}


% subsubsection bibliotecas_utilizadas (end)

%
%~~
%~~ Classe delegadora
%~~
%

\subsubsection{Classe delegadora: \emph{MapDirection}} % (fold)
\label{ssub:classe_delegadora_mapdirection}

Classe delegadora principal da aplicação. Responsável por informar sobre a condições e informações básicas do aparelho e de coordenar todas as View \emph{Controllers} do aplicativo, além de ser o responsável por manter as listas de permanências de dados sobre os últimos endereços usados e endereços favoritos.

Os dados a serem armazenados são manipulados pela classe \emph{NSUsersDefault}, que guarda no \emph{SandBox} da aplicação. Ao iniciar a aplicação, o método \emph{loadDatabase} é chamado. Ao encerrar a aplicação, a classe \emph{delegate} captura essa notificação e assim o processo se retenção de dados é realizada.

\textbf{Reachability:} Para a verificação de conectividade do aparelho, implementou-se uma classe herdada de \emph{SCNetworkReachability}, disponibilizada pela Apple a partir do \emph{SystemConfiguration.framework}. Verifica-se a conexão com a internet via \emph{edge}/\emph{3G} ou \emph{wifi}.



% subsubsection classe_delegadora_mapdirection (end)

%
%~~
%~~ View Controller
%~~
%

\subsubsection{View Controller Principal: \emph{BetterWayViewController}} % (fold)
\label{ssub:view_controller_principal_betterwayviewcontroller}

Esta sessão contém a descrição da classe central da aplicação, sendo o responsável pela funcionalidade de disponibilizar o mapa. Possui o mapa onde é identificado as funcionalidades de geração de rotas, informação do trânsito e de eventos para o usuário. Possui o \emph{UINavigatorController}, que conecta todas as telas da aplicação.
Possui a funcionalidade de localização atual do usuário, através de um botão ativa-se um método que requisita as informações locais para o sistema e move o mapa para a posição do usuário.

\textbf{CLLocationManager:} Classe disponibilizada pela Apple que faz a verificação da disponibilidade do GPS. Possui diversos métodos de utilização do GPS, entre elas o método de buscar as informações da posição atual do usuário.



% subsubsection view_controller_principal_betterwayviewcontroller (end)

%
%~~
%~~ Módulo de geração de rota
%~~
%

\subsubsection{Módulo de geração de rota} % (fold)
\label{ssub:módulo_de_geração_de_rota}

Essa funcionalidade de navegação para a criação de rotas foi estruturada por várias \emph{View Controllers} necessárias para o fluxo de interatividade com o usuário, que entra com os dados da via de destino e origem no aparelho a fim de gerar uma rota evitando os congestionamentos conhecidos pelo servidor.

O fluxo foi definido de tal maneira recursiva para o reaproveitamento das mesmas classes, sendo que ao passar o endereço de destino e o de origem, o usuário passe pelas classes de telas. O diagrama de fluxo encontra-se na seção~\ref{sec:protótipo_de_navegação} do apêndice~\ref{cha:projeto_da_interface_de_usuário}.  Decidimos por implementar algumas funcionalidades auxiliares como um armazenamento de endereços como um histórico e como uma lista favoritos, para uma melhor experiência de utilização para o usuário. 
Uma breve descrição para cada \emph{ViewController} está descrita a seguir:

\textbf{RouteMenuViewController:} \emph{View Controller} que exibe uma lista de opções para o usuário. Para o caso de se selecionar o endereço de destino a classe exibe as opções entrar com endereço ou utilizar da lista de favoritos. Para o caso de se selecionar o endereço de origem ela exibe além das opções disponíveis no caso de endereço destino, a opção de se utilizar o endereço atual do dispositivo (Figura~\ref{fig:seleção_endereço}).
A implementação para obtenção do endereço atual utilizou-se da classe \emph{MKReverseGeocode}, que a partir da posição em relação a latitude e longitude do local, faz a chamada para o serviço de geocodificação da API do \emph{Google Maps}, obtendo assim o endereço completo que existe naquele ponto.


\begin{figure}[htpb]
	\centering
	\includegraphics[scale=0.2]{img/iphone/Destino.png}
	\includegraphics[scale=0.2]{img/iphone/Origem.png}
	\caption{Aplicação na tela de seleção de menu de endereços}
	\label{fig:seleção_endereço}
\end{figure}

Descrição das principais classes utilizadas neste módulo:

\textbf{SearchAddressViewController:} Classe que oferece a interface para o usuário digitar o endereço. Exibe uma lista do histórico da aplicação, que pode ser utilizada sem a necessidade de digitar novamente o endereço já usado. O \emph{framework} do iPhone não disponibiliza a procura de endereços, sendo necessário o uso da API de serviços do \emph{Google Maps} para fazer a verificação da existência do endereço digitado pelo usuário.


\textbf{FavoriteListViewController:} Classe que exibe a lista de favoritos salvos pelo usuário. Pode-se excluir da lista arrastando o dedo encima do endereço favorito salvo, e confirmar a exclusão com o botão que aparece na tela.

% \begin{figure}[htpb]
% 	\centering
% 	\includegraphics[scale=0.2]{img/iphone/FavoriteListViewController.png}
% 	\caption{Aplicação na lista de favoritos}
% \end{figure}

\textbf{CheckAddressViewController:}
Classe que apresenta a tela que exibe informações do endereço encontrado a partir da requisição do usuário. Possui o endereço completo encontrado e um mapa para identificar a redondeza do local (Figura~\ref{fig:searchviewcontroller}). O usuário possui as opções de salvar no favorito, enviar via e-mail e confirmar o endereço. O método de requisição de rotas é realizado a partir da requisição das posições de endereço de destino e origem no servidor. O servidor processa o pedido, e a partir dos dados da situação de trânsito, manipula o trajeto para evitar congestionamento para melhorar a performance no tempo na viagem do usuário. 

\begin{figure}[htpb]
	\centering
	\includegraphics[scale=0.2]{img/iphone/SearchViewController.png}
	\caption{Aplicação exibindo detalhes do endereço na \emph{view} do CheckAddressViewController}
	\label{fig:searchviewcontroller}
\end{figure}

\textbf{FavoriteAddViewController:} \emph{View Controller} com formulário para a entrada no nome do endereço favorito a ser adicionado.

\pagebreak

\textbf{MFMailComposeViewControlle:} Classe auxiliar para o envio via e-mail. O corpo do e-mail é pré-formatado com o endereço do local entrado pelo usuário. Realiza a funcionalidade do software de envio dos \emph{e-mails}.

\textbf{RouteRecalculatorClock:} Para o caso do uso da posição atual do usuário no endereço de origem, o objeto do tipo  \emph{RouteRecalculatorClock} é ativada. A cada 10 segundos é conferida a distância entre o usuário e a rota definida, e caso for maior que 50 metros uma nova requisição de rota é enviada, atualizando o trajeto para a posição original do usuário naquele momento.

\textbf{RoutePolyline:} Objeto do tipo marcação de rota. Possui uma lista de pontos para desenho da rota no mapa.


% subsubsection módulo_de_geração_de_rota (end)

%
%~~
%~~ Módulo de trânsito
%~~
%

\subsubsection{Módulo de trânsito} % (fold)
\label{ssub:módulo_de_trânsito}

Para implementação do módulo de trânsito é utilizado um método para chamadas contínuas de requisições no servidor para adquirir informações sobre a malha de tráfego nas redondezas que o usuário está visualizando. A malha é desenhada como se fosse uma lista de trajetos a serem desenhadas no mapa. A via é colorida a partir da informação da cor a ser renderizada para a via no dado de retorno da requisição.
Uma listagem das principais classes para este módulo encontra-se a seguir:

\textbf{RegisterClock:} Objeto que envia a identificação, posição e velocidade do usuário a cada 3 segundos, sendo responsável pela funcionalidade de trânsito. Inicialmente foi definido que o tempo do momento que o registro é disparado era também enviado para o servidor. Porém não foi levado em consideração que cada aparelho poderia ter horários diferentes, invalidando os dados no servidor. Para solucionar este problema, o servidor ficou responsável por guardar o horário de recebimento do registro.
Um outro problema de integridade dos dados surgiu, pois dependendo da condição de conexão de internet do dispositivo houve casos em que mais de uma requisição de registro era realizada ao mesmo tempo. Cada requisição possuía dados de velocidade diferentes, mas com exatamente o mesmo tempo. Com uma política de envio síncrono dos dados do registro solucionamos este problema, tendo agora a diferença de 3 segundos entre requisições com contato com sucesso ao servidor.

\textbf{TrafficClock:} Objeto que realiza a rotina de atualização da malha de tráfego a cada 30 segundos. Ao movimentar o mapa, faz a requisição automática para estender a malha de tráfego para a região em visualização.

\textbf{TrafficPolyline:} Objeto do tipo anotação no mapa, possuindo uma lista de pontos para desenho da malha de transito. Para cada objeto \emph{TrafficPolyline} é definido uma cor para sua linha, representando as condições do tráfego na região marcada. Responsável pela funcionalidade do software de mapeamento em tempo real apresentando as linhas da malha do tráfego.

% subsubsection módulo_de_trânsito (end)

%
%~~
%~~ Módulo de eventos
%~~
%

\subsubsection{Módulo de eventos} % (fold)
\label{ssub:módulo_de_eventos}

O módulo de eventos contém classes que coordenam os métodos para gerenciar os eventos. Contém uma rotina de requisição da lista de eventos com o servidor que é atualizado a cada 10 segundos, e relacionado com o nível de zoom que o usuário está visualizando no mapa. Dependendo da resposta do servidor novas marcações no mapa de eventos são criados ou removidos.
Para marcação de um novo evento, é possível definir entre 4 tipos: polícia, trânsito, acidente e aviso. O usuário pode colocar uma breve descrição e foto para complementar as informações do evento a ser divulgado. 
Para salvar e disponibilizar a foto, foi realizado um redimensionamento e compressão para que não consuma muito tráfego de internet do dispositivo. Houveram dificuldades no gerenciamento de memória para realizar este tratamento da foto, sendo necessário um esforço na organização de alocação de memória do dispositivo.
As principais classes utilizadas neste módulo estão listadas a seguir:


\textbf{EventClock:} Classe que opera esporadicamente a requisição da lista de eventos no servidor. Entre uma requisição e outra foi definido 8 segundos de espera. Também é responsável por tratar a resposta do servidor.

\textbf{EventListViewController:} View Controller que dispõe para o usuário a escolha de que tipo de evento ele quer criar. Há as opções de Polícia, Trânsito, Acidente e Aviso.

\textbf{EventDetailsViewController:} Classe que disponibiliza a criação do tipo do evento selecionado anteriormente pelo \emph{EventListViewController}. Há espaço para uma descrição e uma foto para uma melhor representação do evento identificado. É o responsável pela função de software de eventos, permitindo o usuário emitir alertas de eventos.

\textbf{EventAnnotation:} Classe do tipo anotação que pode ser adicionada no mapa principal da aplicação.

 

% subsubsection módulo_de_eventos (end)

% subsection aplicativo_móvel (end)

% section implementação (end)
